library(igraph)
g <- graph.formula(1-2,2-3,3-1)

#for plotting directed graph
g1<-graph.formula(1-+2,2-+3,3++1)
plot(g1,vertex.size=60)


plot(g)
#for getting vertices name
V(g)

#for getting edges
E(g)

#for getting count of vertices
vcount(g)

#for getting count of edges
ecount(g)

#for getting in degree and out degree
degree(g,mode='in')
degree(g,mode='out')

#node with lowest degree and highest degree
V(g)$name[degree(g)==min(degree(g))]
V(g)$name[degree(g)==max(degree(g))]

#to get neighbors
neighbors(g,2)

#to get adjacency list
get.adjlist(g)

#to get adjacency matrix
get.adjacency(g)


#import library igraph and do setwd to your csv location
nodes=read.csv('filename',header=T,as.is=T)
head(nodes)
links=read.csv('filename',header=T,as.is=T)

net=graph.data.frame(d=links,vertices=nodes,directed=T)
m=as.matrix(net)
get.adjacency(m)
plot(net)

read.table('a.txt')
#a.txt content as follows
	a 	b 	c 	d
a 	100 200
b
c
d	


#Density calculation
library('igraph')
g<-graph.formula(1-2,2-3,3-4,4-5)
>vcount(g)
[1] 5
> ecount(g)
[1] 4
> ecount(g)/(vcount(g)*(vcount(g)-1))
[1] 0.2

#Reciprocity calculation(only for directed graph)
dg <- graph.formula(1-+2, 1-+3, 2++3)
>plot(dg)
> reciprocity(dg)
[1] 0.5

#Formula as per text book
> dyad.census(dg)
$mut
[1] 1
 
$asym
[1] 2
 
$null
[1] 0
 
> 2*dyad.census(dg)$mut/ecount(dg)
[1] 0.5

##for transitivity
Transitivity

> kite <- graph.famous("Krackhardt_Kite")
> atri <- adjacent.triangles(kite)
> plot(kite, vertex.label=atri)
transitivity(kite, type="local")

textbook formula
adjacent.triangles(kite) / (degree(kite) * (degree(kite)-1)/2)


#centrality
Degree of centrality
> centralization.degree(graph, mode="in", normalized=T)

Closeness Centralization
> closeness(graph, mode="all", weights=NA)
> centralization.closeness(graph, mode="all", normalized=T)

Betweeness Centrality
> betweenness(graph, directed=T, weights=NA)
> edge.betweenness(graph, directed=T, weights=NA)
> centralization.betweenness(graph, directed=T, normalized=T)

Eigenvector centrality
> centralization.evcent(graph, directed=T, normalized=T)


##reading from text
> library(igraph)
> matt <- as.matrix(read.table(text=
 "node  R  S  T  U
           R  7  5  0  0  
          S  7  0  0  2  
         T  0  6  0  0  
        U  4  0  1  0", header=T))
> nms <- matt[,1 ]
> matt <- matt[, -1]
> colnames(matt) <- rownames(matt) <- nms
>  matt[is.na(matt)] <- 0
> g <- graph.adjacency(matt, weighted=TRUE)
> plot(g)

##to get shortest path
> s.paths <- shortest.paths(g, algorithm = "dijkstra")
> print(s.paths)
  R S T U
R 0 5 5 4
S 5 0 3 2
T 5 3 0 1
U 4 2 1 0
> shortest.paths(g, v="R", to="S")
  S
R 5
>plot(g, edge.label=E(g)$weight)

##to get density of graph
library(igraph)
> dg <- graph.formula(1-+2, 1-+3, 2++3)
> plot(dg)
> graph.density(dg, loops=TRUE)
[1] 0.4444444    

i.e(4/9=0.444)

graph.density(simplify(dg), loops=FALSE)
[1] 0.6666667

4/6 =0.666


##for matrix form
get.adjacency(graph)

##for adjacency list
get.adjedgelist(graph,mode='in')
get.adjedgelist(graph,mode='out')

#for edge list
E(graph)


##for structural equivalent
install.packages("sna")
library(sna)
library(igraph)
links<-read.csv("graphs.csv",header=T,row.names = 1)
eq <- equiv.clust(links)
plot(eq)

##for structural equivalent
g.se<-sedist(links)
plot(cmdscale(as.dist(g.se)))

##blockmodelling
b<-blockmodel(links,eq,h=10)
plot(b)


##for creating sociograms
install.packages('Dominance')
library('Dominance')
data(data_Network_1)
bytes="00111111111000000000"
Sociogram(data_Network_1,bytes)
print(data_Network_1)

##SVD
library('igraph')
a<-matrix(c(1,0,0,0,0,0,0,1,1,1,1,1,0,1,0,1,1,1),6,3)
print(a)
svd(a)


##bipartite
library(igraph)
davis <- read.csv(file.choose("C:/Users/student/Documents/"),header=FALSE)
g <- graph.data.frame(davis,directed=FALSE)
plot(g)
bipartite.mapping(g)

V(g)$type <- bipartite_mapping(g)$type
plot(g) #Plotting a bipartite network
plot(g, vertex.label.cex = 0.8, vertex.label.color ="black")
V(g)$color <- ifelse(V(g)$type, "lightblue", "salmon")
V(g)$shape <- ifelse(V(g)$type, "circle", "square")
E(g)$color <- "lightgray"
plot(g, vertex.label.cex = 0.8,vertex.label.color ="black")
V(g)$label.color <- "black"
#label.cex value to adjust our label size
V(g)$label.cex <- 1
V(g)$frame.color <- "gray"
V(g)$size <- 18
plot(g, layout = layout_with_graphopt)
plot(g, layout=layout.bipartite, vertex.size=7,vertex.label.cex=0.6)
library

dataset for bipartite
EVELYN,1 
EVELYN,2
EVELYN,3
EVELYN,4
EVELYN,5
EVELYN,6
EVELYN,7
LAURA,1
LAURA,2
LAURA,3
LAURA,4
LAURA,5
LAURA,6
THERESA,1
THERESA,2

##hamming distance
library('e1071')
x<-c(1,0,0,1)
y<-c(0,0,0,1)
hamming.distance(x,y)